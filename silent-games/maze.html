<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Maze Game - Screen Off Mode</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: manipulation;
            transition: background-color 0.5s;
        }
        
        body.screen-off {
            background-color: #000;
        }
        
        .header {
            text-align: center;
            margin-bottom: 15px;
            color: #fff;
            width: 100%;
        }
        
        .header h1 {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
            width: 100%;
        }
        
        button {
            padding: 10px 15px;
            font-size: 0.9rem;
            border: none;
            border-radius: 8px;
            background: linear-gradient(to bottom, #4CAF50, #3e8e41);
            color: white;
            cursor: pointer;
            box-shadow: 0 3px 5px rgba(0,0,0,0.3);
            transition: all 0.2s;
            font-weight: bold;
        }
        
        button:active {
            transform: translateY(2px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        
        #screenOffButton {
            background: linear-gradient(to bottom, #ff9800, #f57c00);
        }
        
        .game-container {
            display: flex;
            flex-direction: row; /* Modifica per affiancare i canvas */
            justify-content: center; /* Centra i canvas */
            align-items: center;
            flex-wrap: wrap; /* Permette di andare a capo su schermi piccoli */
            width: 100%;
            gap: 20px; /* Aggiunge spazio tra i canvas */
        }
        
        canvas {
            border: 2px solid #333;
            background-color: #222;
            max-width: 100%;
            transition: opacity 0.5s;
        }
        
        body.screen-off canvas, body.screen-off .controls, body.screen-off .instructions  {
            opacity: 0;
        }
        
        #mazeCanvas {
            width: 45vmin; /* Adattato per stare affiancato */
            height: 45vmin;
        }
        
        #currentCellCanvas {
            width: 45vmin; /* Adattato per stare affiancato */
            height: 45vmin;
        }
        
        .instructions {
            text-align: center;
            padding: 20px 0;
            color: #ccc;
            font-size: 0.9rem;
            line-height: 1.4;
            max-width: 90%;
        }
        
        .screen-off-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 1.2rem;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
            z-index: 100;
        }
        
        body.screen-off .screen-off-message {
            opacity: 1;
        }
        
        /* Media query per schermi pi√π grandi */
        @media (min-width: 768px) {
            #mazeCanvas {
                width: 400px;
                height: 400px;
            }
            #currentCellCanvas {
                width: 300px;
                height: 300px;
            }
        }

    </style>
</head>
<body>
    <div class="instructions">
        Use arrow keys or swipe up/down to move forward/backward. Swipe left/right to rotate.<br />
You won't be able to see the entire labyrinth at once. The view is limited to the single tile you are currently on and any surrounding walls.<br />
Your character is a triangle. The point of the triangle indicates the direction you are facing. If you try to move "forward" and the point of the triangle is facing a wall, your character will hit the wall, and you will feel a vibration to signal the obstacle.
        <p class="screen-off-instruction">Long press to turn the screen back on.</p>
    </div>
    
    <div class="controls">
        <button id="toggleMazeButton">Hide Maze</button>
        <button id="screenOffButton">Turn Screen Off</button>
    </div>
    
    <div class="game-container">
        <canvas id="mazeCanvas" style="display:none;"></canvas>
        <canvas id="currentCellCanvas"></canvas>
    </div>
    
    <div class="screen-off-message">
        Screen is off<br>
        Long press to turn on
    </div>

    <script>
        // Generate the maze
        function generateMaze(size) {
            const maze = Array.from({ length: size }, () => Array(size).fill(1));

            function carvePath(x, y) {
                const directions = shuffle([
                    [1, 0], // down
                    [0, 1], // right
                    [-1, 0], // up
                    [0, -1]  // left
                ]);

                for (let [dx, dy] of directions) {
                    const nx = x + dx * 2;
                    const ny = y + dy * 2;

                    if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[nx][ny] === 1) {
                        maze[x + dx][y + dy] = 0;
                        maze[nx][ny] = 0;
                        carvePath(nx, ny);
                    }
                }
            }

            function shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            // Start carving from (1,1)
            maze[1][1] = 0;
            carvePath(1, 1);

            // Set the entrance and exit
            maze[1][1] = 0;
            maze[size - 2][size - 2] = 2; // Adjusted exit to be reachable

            return maze;
        }

        // Global variables
        const size = 21; // Maze size (must be an odd number)
        const maze = generateMaze(size);
        let screenOff = false;
        let longPressTimer = null;
        
        const canvas = document.getElementById('mazeCanvas');
        const ctx = canvas.getContext('2d');
        
        const currentCellCanvas = document.getElementById('currentCellCanvas');
        const ctxCell = currentCellCanvas.getContext('2d');
        
        function resizeCanvases() {
            // Use fixed or responsive sizes from CSS
            const mazeSize = parseFloat(getComputedStyle(canvas).width);
            const cellSize = parseFloat(getComputedStyle(currentCellCanvas).width);

            canvas.width = mazeSize;
            canvas.height = mazeSize;
            
            currentCellCanvas.width = cellSize;
            currentCellCanvas.height = cellSize;
            
            tileSize = Math.floor(canvas.width / size);
            drawMaze();
        }
        
        let tileSize;
        let playerPosition = { x: 1, y: 1 };
        let direction = 0; // 0 = North, 1 = East, 2 = South, 3 = West
        
        function getForwardDelta() {
            switch (direction) {
                case 0: return { dx: 0, dy: -1 }; // North
                case 1: return { dx: 1, dy: 0 };  // East
                case 2: return { dx: 0, dy: 1 };  // South
                case 3: return { dx: -1, dy: 0 }; // West
            }
        }

        function drawMaze() {
            if (!ctx) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = '#000';
                    } else if (maze[y][x] === 2) {
                        ctx.fillStyle = '#0f0'; // Exit
                    } else {
                        ctx.fillStyle = '#fff'; // Path
                    }
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            // Draw player
            ctx.fillStyle = '#00f';
            ctx.fillRect(playerPosition.x * tileSize, playerPosition.y * tileSize, tileSize, tileSize);

            drawCurrentCell();
        }

        function drawCurrentCell() {
            if (!ctxCell) return;
            const cellSize = currentCellCanvas.width;
            ctxCell.clearRect(0, 0, cellSize, cellSize);

            ctxCell.save();
            ctxCell.translate(cellSize / 2, cellSize / 2);
            ctxCell.rotate((-direction * Math.PI) / 2);
            ctxCell.translate(-cellSize / 2, -cellSize / 2);

            const { x, y } = playerPosition;
            const walls = {
                top: maze[y - 1]?.[x] === 1,
                bottom: maze[y + 1]?.[x] === 1,
                left: maze[y]?.[x - 1] === 1,
                right: maze[y]?.[x + 1] === 1,
            };

            ctxCell.fillStyle = screenOff ? '#111' : '#fff';
            ctxCell.fillRect(0, 0, cellSize, cellSize);

            ctxCell.fillStyle = screenOff ? '#333' : '#000';
            if (walls.top) ctxCell.fillRect(0, 0, cellSize, cellSize * 0.2);
            if (walls.bottom) ctxCell.fillRect(0, cellSize * 0.8, cellSize, cellSize * 0.2);
            if (walls.left) ctxCell.fillRect(0, 0, cellSize * 0.2, cellSize);
            if (walls.right) ctxCell.fillRect(cellSize * 0.8, 0, cellSize * 0.2, cellSize);

            ctxCell.restore();

            ctxCell.fillStyle = screenOff ? '#555' : '#00f';
            ctxCell.beginPath();
            const center = cellSize / 2;
            const arrowSize = cellSize * 0.15;
            ctxCell.moveTo(center, center - arrowSize);
            ctxCell.lineTo(center - arrowSize, center + arrowSize);
            ctxCell.lineTo(center + arrowSize, center + arrowSize);
            ctxCell.closePath();
            ctxCell.fill();
        }

        function movePlayer(dx, dy) {
            const newX = playerPosition.x + dx;
            const newY = playerPosition.y + dy;

            if (maze[newY] && maze[newY][newX] !== 1) {
                playerPosition.x = newX;
                playerPosition.y = newY;
                
                if (maze[newY][newX] === 2) {
                    setTimeout(() => {
                        vibrate([100, 30, 100, 30, 100, 30, 200, 30, 200]);
                        alert('You won!');
                        playerPosition = { x: 1, y: 1 };
                        drawMaze();
                    }, 100);
                }
                
                drawMaze();
                return true;
            }
            vibrate(100);
            return false;
        }

        function vibrate(pattern) {
            if (navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }

        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
            
            if (screenOff) {
                longPressTimer = setTimeout(turnScreenOn, 1000);
            }
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            
            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            handleSwipe(touchEndX - touchStartX, touchEndY - touchStartY);
        });

        function handleSwipe(diffX, diffY) {
            const minSwipeDistance = 30;

            if (Math.abs(diffX) > Math.abs(diffY)) {
                if (Math.abs(diffX) > minSwipeDistance) {
                    direction = (diffX > 0) ? (direction + 1) % 4 : (direction + 3) % 4;
                    drawMaze();
                }
            } else {
                if (Math.abs(diffY) > minSwipeDistance) {
                    const { dx, dy } = getForwardDelta();
                    if (diffY > 0) {
                        movePlayer(-dx, -dy); // Backward
                    } else {
                        movePlayer(dx, dy);  // Forward
                    }
                }
            }
        }
        
        // --- KEYBOARD CONTROLS ---
        document.addEventListener('keydown', (e) => {
            const { dx, dy } = getForwardDelta();
            switch (e.key) {
                case 'ArrowUp':
                    movePlayer(dx, dy); // Move forward
                    break;
                case 'ArrowDown':
                    movePlayer(-dx, -dy); // Move backward
                    break;
                case 'ArrowLeft':
                    direction = (direction + 3) % 4; // Rotate left
                    drawMaze();
                    break;
                case 'ArrowRight':
                    direction = (direction + 1) % 4; // Rotate right
                    drawMaze();
                    break;
            }
        });


        /*currentCellCanvas.addEventListener('touchstart', (e) => {
            const rect = currentCellCanvas.getBoundingClientRect();
            const touchX = e.changedTouches[0].clientX - rect.left;
            const touchY = e.changedTouches[0].clientY - rect.top;
            
            const edgeThreshold = 0.2;
            let edge = null;
            if (touchY < rect.height * edgeThreshold) edge = 'top';
            else if (touchY > rect.height * (1 - edgeThreshold)) edge = 'bottom';
            else if (touchX < rect.width * edgeThreshold) edge = 'left';
            else if (touchX > rect.width * (1 - edgeThreshold)) edge = 'right';
            
            if (edge) {
                let wallExists = false;
                const {x, y} = playerPosition;
                switch (edge) {
                    case 'top': wallExists = maze[y - 1]?.[x] === 1; break;
                    case 'bottom': wallExists = maze[y + 1]?.[x] === 1; break;
                    case 'left': wallExists = maze[y]?.[x - 1] === 1; break;
                    case 'right': wallExists = maze[y]?.[x + 1] === 1; break;
                }
                if (wallExists) vibrate(50);
            }
        }, { passive: true });*/

        function turnScreenOff() {
            screenOff = true;
            document.body.classList.add('screen-off');
            drawMaze();
        }
        
        function turnScreenOn() {
            screenOff = false;
            document.body.classList.remove('screen-off');
            drawMaze();
        }

        document.getElementById('screenOffButton').addEventListener('click', turnScreenOff);
        document.getElementById('toggleMazeButton').addEventListener('click', () => {
            const mazeCanvas = document.getElementById('mazeCanvas');
            if (mazeCanvas.style.display === 'none') {
                mazeCanvas.style.display = 'block';
                document.getElementById('toggleMazeButton').textContent = 'Hide Maze';
            } else {
                mazeCanvas.style.display = 'none';
                document.getElementById('toggleMazeButton').textContent = 'Show Maze';
            }
        });

        window.addEventListener('resize', resizeCanvases);
        
        // Initialization
        resizeCanvases();
    </script>
</body>
</html>```

